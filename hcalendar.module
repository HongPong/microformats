<?php
/**
 * @file
 * submit, view, and manage hCalendar items and lists
 */

/**
 * Implementation of hook_help()
 * Display help text for the hcalendar module 
 */
function hcalendar_help($section) {
  switch ($section) {
    case 'admin/help#hcalendar':
      $o .= '<p>' . t('Submit, view and manage hCalendar lists.') . '</p>';
      return $o;
    case 'admin/modules#description':
      return t('Allows users to submit, view and manage hCalendar items and lists.');
    case 'node/add#hcalendar':
      return t('Add a hCalendar item here.');
  }
}

/**
 * Implementation of hook_node_info().
 * Define the node type
 */
function hcalendar_node_info() {
	return array(
		'hcalendar' => array(
			'name' => t('hCalendar'),
			'module' => ('hcalendar'),
			'base' => ('hcalendar'),
			'description' => t('hCalendar is a simple, open, distributed calendaring and events format, based on the iCalendar standard (RFC2445 (http://www.ietf.org/rfc/rfc2445.txt)), suitable for embedding in (X)HTML, Atom, RSS, and arbitrary XML. hCalendar is one of several open microformat standards.')
		)
	);
}

/**
 * Implementation of hook_perm().
 * Define the permissions this module uses
 */
function hcalendar_perm() {
  return array('create hCalendar items', 'manage own hCalendar items');
}

/**
 * Implementation of hook_access().
 */
function hcalendar_access($op, $node) {
  global $user;

  if ($op == 'create') {
    return user_access('create hCalendar items');
  }

  if ($op == 'update' || $op == 'delete') {
    if (user_access('manage own hCalendar items') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_menu().
 */
function hcalendar_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'node/add/hcalendar', 'title' => t('hCalendar Entry'),
      'access' => user_access('create hCalendar entry'));
  }

  return $items;
}

/**
 * Implementation of hook_form().
 */
function hCalendar_form(&$node) {
	
	// summary / title
	$form['title'] = array(
		'#type' => 'textfield',
		'#title' => t('Summary'),
		'#required' => TRUE, 
		'#default_value' => $node->title, 
		'#weight' => -5, 
		'#description' => t('A Summary of the hCalendar event.')
	);
	
	$form['location'] = array(
		'#type' => 'textfield',
		'#title' => t('Location'),
		'#required' => FALSE, 
		'#default_value' => $node->location, 
		'#weight' => -4, 
		'#description' => t('Location of the hCalendar event.')
	);
	
	$form['url'] = array(
		'#type' => 'textfield',
		'#title' => t('URL'),
		'#required' => FALSE, 
		'#default_value' => $node->url, 
		'#weight' => -3, 
		'#description' => t('URL for hCalendar event.')
	);
	
	// start date 
	$form['startdate'] = array(
    	'#type' => 'textfield', 
    	'#title' => t('Start date'), 
    	'#required' => TRUE, 
    	'#default_value' => $node->startdate, 
    	'#weight' => -2,
    	'#description' => 'Format DD/MM/YYYY'
	);
	
	// end date 
	$form['enddate'] = array(
    	'#type' => 'textfield', 
    	'#title' => t('End date'), 
    	'#required' => FALSE, 
    	'#default_value' => $node->enddate, 
    	'#weight' => -1,
    	'#description' => 'Format DD/MM/YYYY'
	);
	
	// priority
	$tz = _hCalendar_tz();
	$form['timezone'] = array(
		'#type' => 'select', 
		'#title' => t('Time Zone'), 
		'#required' => FALSE, 
		'#default_value' => $node->tz, 
		'#options' => $tz,
		'#weight' => 0
	);
	
	 // full description / body
	 $form['body_filter']['body'] = array(
	 	'#type' => 'textarea',
		'#title' => t('hCalendar details'),
		'#default_value' => $node->body,
		'#rows' => 10,
		'#required' => FALSE
  );
  
  return $form;
}

/**
 * Return an array of Timezones
 * @return array of Timezones
 */
function _hCalendar_tz() {
  return array('none', '-1200', '-1100', '-1000', '-0900', '-0800', '-0700', '-0600', '-0500', '-0400', '-0300', '-0200', '-0100', 'Z', '+0100', '+0200', '+0300', '+0400', '+0500', '+0600', '+0700', '+0800', '+0900', '+1000', '+1100', '+1200');
}

/**
 * Validate our forms
 * @param string form id
 * @param array form values
 */
function hcalendar_validate($form_id, $form_values) {

    // if the user specified a date, validate the format
    if (isset($form_values['startdate']) && (trim($form_values['startdate']['#value']) != '')) {
       
        // check the date format
        if (!preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d)$/', $form_values['startdate']['#value'], $matches)) {
            form_set_error('startdate', t('Start date should be in the format dd/mm/yyyy'));
        } else {

            // make sure the date provided is a validate date
            if (!checkdate($matches[2], $matches[1], $matches[3])) {
                form_set_error('startdate', t('Please enter a valid date'));
            }
           
        }
    }
	
	// if the user specified a date, validate the format
    if (isset($form_values['enddate']) && (trim($form_values['enddate']['#value']) != '')) {
       
        // check the date format
        if (!preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d)$/', $form_values['enddate']['#value'], $matches)) {
            form_set_error('enddate', t('End date should be in the format dd/mm/yyyy'));
        } else {

            // make sure the date provided is a validate date
            if (!checkdate($matches[2], $matches[1], $matches[3])) {
                form_set_error('enddate', t('Please enter a valid date'));
            }
           
        }
    }
}

/**
 * Implementation of hook_insert, which saves todo-specific information
 * into the todo table
 * @param node object
 */
function hcalendar_insert($node) {

    // normally, we'd try strtotime, but it won't handle the inverse
    // dd/mm/yyyy formats, so generate the timestamp ourselves
    preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d)$/', $node->startdate, $m1);
    $ts1 = mktime(0, 0, 0, $m1[2], $m1[1], $m1[3]);
	
	preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d)$/', $node->enddate, $m2);
    $ts2 = mktime(0, 0, 0, $m2[2], $m2[1], $m2[3]);
   
    db_query("INSERT INTO {hcalendar} (nid, location, url, startdate, enddate, timezone) VALUES (%d, '%s', '%s', %d, %d, %d)", $node->nid, $node->location, $node->url, $ts1, $ts2, $node->timezone);
}

function hcalendar_delete(&$node) {
	db_query('DELETE FROM {hcalendar} WHERE nid = %d', $node->nid);
}

/**
 * Implemenation of hook_load 
 * @param node object to load additional information for
 * @return object with hcalendar fields 
 */
function hcalendar_load($node) {
	$t = db_fetch_object(db_query('SELECT nid, location, url, startdate, enddate, timezone FROM {hcalendar} WHERE nid = %d', $node->nid));
	return $t;
}

/**
 * Implemenation of hook_prepare
 * @param node object to display
 */
function hcalendar_prepare(&$node) {
    $node->duedate = date('Y-m-d', $node->duedate);
}

function todo_update($node) {

    // normally, we'd try strtotime, but it won't handle the inverse
    // dd/mm/yyyy formats, so generate the timestamp ourselves
    preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d)$/', $node->startdate, $m1);
    $ts1 = mktime(0, 0, 0, $m1[2], $m1[1], $m1[3]);
	
	preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d)$/', $node->enddate, $m2);
    $ts2 = mktime(0, 0, 0, $m2[2], $m2[1], $m2[3]);
   
    db_query("UPDATE {hcalendar} set location='%s', url='%s', startdate=%d, enddate=%d, timezone=%d WHERE nid=%d", $node->location, $node->url, $ts1, $ts2, $node->timezone, $node->nid);
}

/**
 * Implementation of hook_view, add our node specific information
 * @param node object to display
 * @param boolean is this a teaser or full node?
 * @param boolean is this displaying on its own page
 */
function hcalendar_view(&$node, $teaser = FALSE, $page = FALSE) {
    $node = node_prepare($node, $teaser);
    $hcalendar_info = theme('hcalendar_basic_view', $node);
    $node->body .= $hcalendar_info;
    $node->teaser .= $hcalender_info;
}

/**
 * Theme function to display additional node data
 * @param node to display
 * @return HTML string with additional node information
 */
function theme_hcalendar_basic_view($node) {

  $output = '<div class="vevent">';
  $output .= t('<a class="url" href="%url">', array('%url' => $node->url));

  $output .= t('<abbr class="dtstart" title="%starttime1">', array('%starttime1' => format_date($node->startdate, 'custom', 'Ymd')));;
  $output .= t('%starttime2</abbr>', array('%startdate2' => format_date($node->startdate, 'custom', 'D M Y')));
  $output .= '</div>';

  return $output;
}